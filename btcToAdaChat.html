<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC to ADA (Simple)</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
        h1 { font-size: 20px; margin: 0 0 12px 0; }
        .note { font-size: 12px; color: #555; margin-bottom: 12px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
        th:first-child, td:first-child { text-align: left; white-space: nowrap; }
        tbody tr:nth-child(even) { background: #fafafa; }
    </style>
    <link rel="icon" href="data:,">
    <!-- minimal favicon to avoid 404 -->
    
</head>
<body>
    <h1>Bitcoin to ADA</h1>
    <div class="note">Data from Binance. Values are daily closes. BTC in ADA = BTC(USD) / ADA(USD).</div>
    <div style="margin: 8px 0 12px 0; display:flex; gap:8px; align-items:center">
        <label for="range-select" style="font-size:14px">Time span:</label>
        <select id="range-select" style="font-size:14px; padding:4px">
            <option value="max">Full history</option>
            <option value="365">Past year</option>
            <option value="180">Past 6 months</option>
            <option value="30" selected>Past month</option>
            <option value="7">Past week</option>
            <option value="1">Past day</option>
        </select>
        <label for="pair-select" style="font-size:14px; margin-left:8px">Pair:</label>
        <select id="pair-select" style="font-size:14px; padding:4px">
            <option value="ADA/BTC" selected>ADA/BTC</option>
            <option value="BTC/ADA">BTC/ADA</option>
        </select>
    </div>
    <div id="status" class="note" aria-live="polite"></div>
    <div style="margin: 8px 0 12px 0;">
        <canvas id="chart" height="240" style="width:100%; display:block; background:#fff; border:1px solid #eee"></canvas>
    </div>
    <table id="data-table">
        <thead>
            <tr>
                <th>Date</th>
                <th>BTC (USD)</th>
                <th>ADA (USD)</th>
                <th>BTC in ADA</th>
            </tr>
        </thead>
        <tbody>
            <tr><td colspan="4" style="text-align:center">Loading…</td></tr>
        </tbody>
    </table>

    <script>
    (function() {
        const tbody = document.querySelector('#data-table tbody');
        const rangeSelect = document.getElementById('range-select');
        const pairSelect = document.getElementById('pair-select');
        const statusEl = document.getElementById('status');
        const canvas = document.getElementById('chart');
        const ctx = canvas.getContext('2d');
        let currentController = null;
        let currentRows = [];

        function formatDate(timestampMs) {
            const d = new Date(timestampMs);
            return d.toISOString().slice(0, 10);
        }

        function formatUsd(value) {
            if (!isFinite(value)) return '-';
            if (value >= 1000) {
                return value.toLocaleString(undefined, { maximumFractionDigits: 0 });
            }
            return value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function formatAda(value) {
            if (!isFinite(value)) return '-';
            return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
        }

        function setStatus(message, isError) {
            statusEl.textContent = message || '';
            statusEl.style.color = isError ? '#b00' : '#555';
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fetchWithRetry(url, options) {
            const { signal } = options || {};
            let attempt = 0;
            const maxAttempts = 2; // one retry on 429/network
            while (true) {
                attempt++;
                try {
                    const res = await fetch(url, { ...options, signal });
                    if (res.status === 429) {
                        if (attempt >= maxAttempts) return res; // let caller handle
                        const retryAfter = Number(res.headers.get('retry-after'));
                        const waitMs = Number.isFinite(retryAfter) ? retryAfter * 1000 : 1500;
                        await sleep(waitMs);
                        continue;
                    }
                    return res;
                } catch (e) {
                    if (signal && signal.aborted) throw e;
                    if (attempt >= maxAttempts) throw e;
                    await sleep(1000);
                }
            }
        }

        function getSeries(rows, pair) {
            // rows have: { date, btcUsd, adaUsd, ratio } where ratio = BTC/ADA (ADA per BTC)
            if (pair === 'ADA/BTC') {
                return rows.map(r => ({ x: r.date, y: r.adaUsd / r.btcUsd })); // BTC per ADA
            }
            return rows.map(r => ({ x: r.date, y: r.ratio })); // ADA per BTC
        }

        function drawChart(rows, pair) {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const cssHeight = 240; // matches canvas height attribute
            const cssWidth = Math.max(200, Math.floor(rect.width));
            canvas.width = Math.round(cssWidth * dpr);
            canvas.height = Math.round(cssHeight * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, cssWidth, cssHeight);

            const series = getSeries(rows, pair);
            if (!series.length) return;

            const padLeft = 40, padRight = 10, padTop = 10, padBottom = 24;
            const plotW = cssWidth - padLeft - padRight;
            const plotH = cssHeight - padTop - padBottom;
            const values = series.map(p => p.y).filter(v => Number.isFinite(v));
            let minY = Math.min(...values);
            let maxY = Math.max(...values);
            if (!isFinite(minY) || !isFinite(maxY)) return;
            if (minY === maxY) {
                const delta = Math.abs(minY) || 1;
                minY -= delta * 0.01;
                maxY += delta * 0.01;
            }

            // axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padLeft, padTop);
            ctx.lineTo(padLeft, padTop + plotH);
            ctx.lineTo(padLeft + plotW, padTop + plotH);
            ctx.stroke();

            // line
            ctx.strokeStyle = pair === 'ADA/BTC' ? '#0a7' : '#a70';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            series.forEach((p, i) => {
                const x = padLeft + (i / Math.max(1, series.length - 1)) * plotW;
                const y = padTop + (1 - (p.y - minY) / (maxY - minY)) * plotH;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // y labels: min/max
            ctx.fillStyle = '#555';
            ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(minY.toLocaleString(undefined, { maximumFractionDigits: 8 }), padLeft - 6, padTop + plotH);
            ctx.fillText(maxY.toLocaleString(undefined, { maximumFractionDigits: 8 }), padLeft - 6, padTop);

            // title label
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(pair + ' (daily close)', padLeft, padTop - 2 + 12);
        }

        async function loadData(daysParam) {
            // Binance supports up to 1000 candles by limit; map max to 1000
            const queryDays = daysParam === 'max' ? '1000' : String(daysParam);
            const daysInt = Math.max(1, parseInt(queryDays, 10) || 30);

            if (currentController) currentController.abort();
            currentController = new AbortController();
            const { signal } = currentController;

            const timeoutId = setTimeout(() => currentController && currentController.abort(), 15000);

            tbody.innerHTML = '<tr><td colspan="4" style="text-align:center">Loading…</td></tr>';
            setStatus('Loading ' + (queryDays === '1000' && daysParam === 'max' ? 'full history (limited to 1000 days)…' : 'data…'));
            rangeSelect.disabled = true;

            try {
                const btcUrl = 'https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1d&limit=' + daysInt;
                const adaUrl = 'https://api.binance.com/api/v3/klines?symbol=ADAUSDT&interval=1d&limit=' + daysInt;
                const [btcRes, adaRes] = await Promise.all([
                    fetchWithRetry(btcUrl, { signal }),
                    fetchWithRetry(adaUrl, { signal })
                ]);

                if (!btcRes.ok || !adaRes.ok) {
                    const msg = (btcRes.status === 429 || adaRes.status === 429)
                        ? 'Rate limited by data provider. Try a smaller range or wait a minute.'
                        : 'Failed to load data (' + btcRes.status + '/' + adaRes.status + ').';
                    throw new Error(msg);
                }

                const [btcData, adaData] = await Promise.all([btcRes.json(), adaRes.json()]);
                const btcKlines = Array.isArray(btcData) ? btcData : [];
                const adaKlines = Array.isArray(adaData) ? adaData : [];

                const length = Math.min(btcKlines.length, adaKlines.length);
                const rows = [];

                for (let i = 0; i < length; i++) {
                    const btc = btcKlines[i];
                    const ada = adaKlines[i];
                    const openTime = Number(btc && btc[0]);
                    const btcClose = Number(btc && btc[4]);
                    const adaClose = Number(ada && ada[4]);
                    const ratio = btcClose / adaClose; // ADA per 1 BTC
                    rows.push({ date: formatDate(openTime), btcUsd: btcClose, adaUsd: adaClose, ratio });
                }

                tbody.innerHTML = '';
                if (rows.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#b00">No data available</td></tr>';
                    setStatus('No data returned.', true);
                    return;
                }

                rows.forEach(r => {
                    const tr = document.createElement('tr');
                    tr.innerHTML =
                        '<td style="text-align:left">' + r.date + '</td>' +
                        '<td>' + formatUsd(r.btcUsd) + '</td>' +
                        '<td>' + formatUsd(r.adaUsd) + '</td>' +
                        '<td>' + formatAda(r.ratio) + '</td>';
                    tbody.appendChild(tr);
                });
                currentRows = rows;
                drawChart(currentRows, pairSelect.value);
                setStatus('Loaded ' + rows.length + ' days.');
            } catch (err) {
                if (err && err.name === 'AbortError') {
                    return;
                }
                console.error(err);
                tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#b00">Error loading data</td></tr>';
                setStatus(String(err && err.message ? err.message : 'Error loading data'), true);
            } finally {
                clearTimeout(timeoutId);
                rangeSelect.disabled = false;
            }
        }

        rangeSelect.addEventListener('change', function() {
            loadData(rangeSelect.value);
        });
        
        pairSelect.addEventListener('change', function() {
            drawChart(currentRows, pairSelect.value);
        });

        // initial load
        loadData(rangeSelect.value);
        
        window.addEventListener('resize', function() {
            drawChart(currentRows, pairSelect.value);
        });
    })();
    </script>
</body>
</html>

