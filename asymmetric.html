<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECC Asymmetric Encryption Tool</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --light: #e8f1f5;
            --dark: #1b3a5d;
            --danger: #d9534f;
            --success: #5cb85c;
            --warning: #f0ad4e;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: var(--light);
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: var(--dark);
            text-align: center;
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--primary);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f1f1f1;
            color: #333;
            border: none;
            outline: none;
            transition: 0.3s;
            font-weight: bold;
        }
        
        .tab:hover {
            background-color: #ddd;
        }
        
        .tab.active {
            background-color: var(--dark);
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            border: 1px solid #ddd;
            border-top: none;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }
        
        .keys-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .key-display {
            flex: 1;
            min-width: 300px;
        }
        
        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: monospace;
            margin-bottom: 10px;
            min-height: 120px;
        }
        
        button {
            background-color: var(--dark);
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px 0;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: var(--dark);
        }
        
        button.secondary {
            background-color: var(--secondary);
        }
        
        button.warning {
            background-color: var(--warning);
        }
        
        button.danger {
            background-color: var(--danger);
        }
        
        button.success {
            background-color: var(--success);
        }
        
        .info-box {
            background-color: #e8f4f8;
            border-left: 5px solid var(--primary);
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .warning-box {
            background-color: #fff3cd;
            border-left: 5px solid var(--warning);
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .note {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
        }
        
        .progress-container {
            width: 100%;
            background-color: #f1f1f1;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        
        .progress-bar {
            height: 20px;
            background-color: var(--primary);
            border-radius: 4px;
            width: 0%;
            text-align: center;
            color: white;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Elliptic Curve Encryption Tool</h1>
        
        <div class="info-box">
            <p><strong>How it works:</strong> This tool uses Elliptic Curve Cryptography (ECC) for asymmetric encryption. Share your public key with others so they can send you encrypted messages that only you can decrypt with your private key.</p>
        </div>
        
        <div class="warning-box">
            <h3>⚠️ Security Notice</h3>
            <p><strong>This tool is intended for casual use only.</strong> While it implements standard cryptographic algorithms, it has several limitations:</p>
            <ul>
                <li>It runs entirely in the browser, which is not a secure environment for highly sensitive cryptographic operations</li>
                <li>Browser JavaScript implementations can have vulnerabilities and side-channel attack risks</li>
                <li>The code has not been audited by security professionals</li>
                <li>Your keys may remain in browser memory even after closing the page</li>
            </ul>
            <p>For truly sensitive communications, please use dedicated, audited encryption software or services like Signal, PGP, or other specialized tools built by security experts.</p>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="openTab(event, 'keyGen')">Generate Keys</button>
            <button class="tab" onclick="openTab(event, 'encrypt')">Encrypt Message</button>
            <button class="tab" onclick="openTab(event, 'decrypt')">Decrypt Message</button>
            <button class="tab" onclick="openTab(event, 'test')">Test Tool</button>
            <button class="tab" onclick="openTab(event, 'about')">How It Works</button>
        </div>
        
        <div id="keyGen" class="tab-content" style="display: block;">
            <h2>Generate Key Pair</h2>
            <p>Generate a new ECC key pair for encryption and decryption.</p>
            
            <div>
                <label for="curveSelect">Select Curve:</label>
                <select id="curveSelect">
                    <option value="P-256">NIST P-256 (recommended)</option>
                    <option value="P-384">NIST P-384 (stronger)</option>
                    <option value="P-521">NIST P-521 (strongest)</option>
                </select>
            </div>
            
            <div class="progress-container" id="keyGenProgress">
                <div class="progress-bar" id="keyGenProgressBar">Generating...</div>
            </div>
            
            <button id="generateKeysBtn" onclick="generateKeyPair()">Generate New Keys</button>
            
            <div class="keys-section">
                <div class="key-display">
                    <h3>Public Key</h3>
                    <textarea id="publicKeyDisplay" readonly placeholder="Your public key will appear here..."></textarea>
                    <button onclick="copyToClipboard('publicKeyDisplay')">Copy Public Key</button>
                </div>
                
                <div class="key-display">
                    <h3>Private Key</h3>
                    <textarea id="privateKeyDisplay" readonly placeholder="Your private key will appear here..."></textarea>
                    <button onclick="copyToClipboard('privateKeyDisplay')">Copy Private Key</button>
                    <p class="note"><strong>Warning:</strong> Keep your private key secure and never share it with others.</p>
                </div>
            </div>
            
            <div>
                <h3>Save/Load Keys</h3>
                <button onclick="saveKeysToFile()">Save Keys to File</button>
                <button onclick="document.getElementById('loadKeysFile').click()">Load Keys from File</button>
                <input type="file" id="loadKeysFile" style="display: none;" onchange="loadKeysFromFile(this.files)">
            </div>
        </div>
        
        <div id="encrypt" class="tab-content">
            <h2>Encrypt Message</h2>
            <p>Encrypt a message using a public key.</p>
            
            <div>
                <h3>Recipient's Public Key</h3>
                <textarea id="encryptPublicKey" placeholder="Paste recipient's public key here..."></textarea>
            </div>
            
            <div>
                <h3>Message to Encrypt</h3>
                <textarea id="messageToEncrypt" placeholder="Type or paste the message you want to encrypt..."></textarea>
            </div>
            
            <button onclick="encryptMessage()" class="primary">Encrypt Message</button>
            
            <div>
                <h3>Encrypted Message</h3>
                <textarea id="encryptedMessage" readonly placeholder="Encrypted message will appear here..."></textarea>
                <button onclick="copyToClipboard('encryptedMessage')">Copy Encrypted Message</button>
            </div>
        </div>
        
        <div id="decrypt" class="tab-content">
            <h2>Decrypt Message</h2>
            <p>Decrypt a message using your private key.</p>
            
            <div>
                <h3>Your Private Key</h3>
                <textarea id="decryptPrivateKey" placeholder="Paste your private key here..."></textarea>
            </div>
            
            <div>
                <h3>Encrypted Message</h3>
                <textarea id="messageToDecrypt" placeholder="Paste the encrypted message here..."></textarea>
            </div>
            
            <button onclick="decryptMessage()" class="primary">Decrypt Message</button>
            
            <div>
                <h3>Decrypted Message</h3>
                <textarea id="decryptedMessage" readonly placeholder="Decrypted message will appear here..."></textarea>
                <button onclick="copyToClipboard('decryptedMessage')">Copy Decrypted Message</button>
            </div>
        </div>
        
        <div id="test" class="tab-content">
            <h2>End-to-End Test</h2>
            <p>Run a complete encryption and decryption test to verify the tool works correctly.</p>
            
            <div class="info-box">
                <p>This test will:</p>
                <ol>
                    <li>Generate a new key pair</li>
                    <li>Use the public key to encrypt a test message</li>
                    <li>Use the private key to decrypt the message</li>
                    <li>Verify that the decrypted message matches the original</li>
                </ol>
            </div>
            
            <div>
                <h3>Test Message</h3>
                <textarea id="testMessage" placeholder="Enter a test message or use the default one">This is a test message to verify that the encryption and decryption functionality works correctly.</textarea>
            </div>
            
            <button id="runTestBtn" onclick="runEndToEndTest()">Run End-to-End Test</button>
            
            <div id="testResults" class="info-box" style="display: none; margin-top: 20px;">
                <h3>Test Results</h3>
                <div id="testResultsContent"></div>
            </div>
        </div>
        
        <div id="about" class="tab-content">
            <h2>How Elliptic Curve Encryption Works</h2>
            
            <div class="info-box">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Public Key:</strong> Used to encrypt messages. Can be freely shared with anyone.</li>
                    <li><strong>Private Key:</strong> Used to decrypt messages. Must be kept secret.</li>
                    <li><strong>Elliptic Curve Cryptography (ECC):</strong> This tool uses ECC which provides strong security with smaller key sizes compared to RSA.</li>
                </ul>
                
                <h3>Advantages of ECC</h3>
                <ul>
                    <li><strong>Smaller Key Sizes:</strong> ECC provides the same security level as RSA but with much smaller keys.</li>
                    <li><strong>Faster Operations:</strong> Key generation and encryption/decryption are typically faster with ECC.</li>
                    <li><strong>Lower Resource Usage:</strong> ECC requires less computational power and memory.</li>
                </ul>
                
                <h3>Encryption Process</h3>
                <ol>
                    <li>Recipient generates an ECC key pair (public and private keys).</li>
                    <li>Recipient shares their public key with the sender.</li>
                    <li>Sender uses the recipient's public key to encrypt a message.</li>
                    <li>Sender sends the encrypted message to the recipient.</li>
                    <li>Recipient uses their private key to decrypt the message.</li>
                </ol>
                
                <h3>Implementation Details</h3>
                <p>This tool uses:</p>
                <ul>
                    <li>ECDH (Elliptic Curve Diffie-Hellman) for key agreement</li>
                    <li>AES-GCM for symmetric encryption of the actual message</li>
                    <li>NIST curves P-256, P-384, and P-521</li>
                </ul>
                
                <h3>Security Notes</h3>
                <ul>
                    <li>All encryption/decryption happens locally in your browser.</li>
                    <li>No data is sent to any server.</li>
                    <li>The default P-256 curve provides strong security for most purposes.</li>
                    <li>Always keep your private key secure.</li>
                </ul>
                
                <h3>Limitations</h3>
                <p>This tool is best suited for:</p>
                <ul>
                    <li>Learning about asymmetric encryption concepts</li>
                    <li>Quick, casual message protection</li>
                    <li>Non-critical communication where convenience is more important than absolute security</li>
                </ul>
                <p>It's not suitable for encrypting sensitive business information, personal health data, financial records, or other highly confidential content.</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        // Tab functionality
        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            
            const tablinks = document.getElementsByClassName("tab");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
        
        // Utility to copy to clipboard
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            document.execCommand("copy");
            
            // Visual feedback
            const originalValue = element.value;
            const originalBackground = element.style.backgroundColor;
            
            element.style.backgroundColor = "#d4edda";
            setTimeout(() => {
                element.style.backgroundColor = originalBackground;
            }, 500);
        }
        
        // Convert ArrayBuffer to Base64 string
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }
        
        // Convert Base64 string to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // Convert string to ArrayBuffer
        function stringToArrayBuffer(str) {
            const encoder = new TextEncoder();
            return encoder.encode(str).buffer;
        }
        
        // Convert ArrayBuffer to string
        function arrayBufferToString(buffer) {
            const decoder = new TextDecoder();
            return decoder.decode(buffer);
        }
        
        // Generate ECC key pair
        async function generateKeyPair() {
            const progressContainer = document.getElementById('keyGenProgress');
            const progressBar = document.getElementById('keyGenProgressBar');
            const generateBtn = document.getElementById('generateKeysBtn');
            const curveSelect = document.getElementById('curveSelect');
            const selectedCurve = curveSelect.value;
            
            // Show progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '30%';
            progressBar.textContent = 'Generating keys...';
            generateBtn.disabled = true;
            
            try {
                // Generate key pair using Web Crypto API
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: selectedCurve
                    },
                    true, // extractable
                    ["deriveKey", "deriveBits"] // usages
                );
                
                progressBar.style.width = '60%';
                
                // Export public key to spki format
                const publicKeyExported = await window.crypto.subtle.exportKey(
                    "spki",
                    keyPair.publicKey
                );
                
                // Export private key to pkcs8 format
                const privateKeyExported = await window.crypto.subtle.exportKey(
                    "pkcs8",
                    keyPair.privateKey
                );
                
                progressBar.style.width = '90%';
                
                // Convert to base64 for storage and display
                const publicKeyBase64 = arrayBufferToBase64(publicKeyExported);
                const privateKeyBase64 = arrayBufferToBase64(privateKeyExported);
                
                // Add curve info to the keys for later use
                const publicKeyWithCurve = JSON.stringify({
                    curve: selectedCurve,
                    key: publicKeyBase64
                });
                
                const privateKeyWithCurve = JSON.stringify({
                    curve: selectedCurve,
                    key: privateKeyBase64
                });
                
                // Display the keys
                document.getElementById('publicKeyDisplay').value = publicKeyWithCurve;
                document.getElementById('privateKeyDisplay').value = privateKeyWithCurve;
                
                // Auto-fill the decryption field only
                document.getElementById('decryptPrivateKey').value = privateKeyWithCurve;
                
                progressBar.style.width = '100%';
                progressBar.textContent = 'Complete!';
                
                // Hide progress after a delay
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    progressBar.style.width = '0%';
                    generateBtn.disabled = false;
                }, 1000);
                
            } catch (error) {
                console.error('Error generating keys:', error);
                progressBar.style.width = '100%';
                progressBar.textContent = 'Error generating keys';
                progressBar.style.backgroundColor = 'var(--danger)';
                
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    progressBar.style.width = '0%';
                    progressBar.style.backgroundColor = 'var(--primary)';
                    generateBtn.disabled = false;
                }, 2000);
            }
        }
        
        // Encrypt message
        async function encryptMessage() {
            const publicKeyJson = document.getElementById('encryptPublicKey').value.trim();
            const messageToEncrypt = document.getElementById('messageToEncrypt').value;
            
            if (!publicKeyJson) {
                alert("Please enter a public key.");
                return;
            }
            
            if (!messageToEncrypt) {
                alert("Please enter a message to encrypt.");
                return;
            }
            
            try {
                // Parse the public key JSON to get curve and key
                const publicKeyData = JSON.parse(publicKeyJson);
                const curve = publicKeyData.curve;
                const publicKeyBase64 = publicKeyData.key;
                
                // Convert base64 to ArrayBuffer
                const publicKeyBuffer = base64ToArrayBuffer(publicKeyBase64);
                
                // Import the public key
                const publicKey = await window.crypto.subtle.importKey(
                    "spki",
                    publicKeyBuffer,
                    {
                        name: "ECDH",
                        namedCurve: curve
                    },
                    true,
                    [] // No usages for public key alone
                );
                
                // Generate an ephemeral key pair for this encryption
                const ephemeralKeyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: curve
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
                
                // Export the ephemeral public key to send along with the message
                const ephemeralPublicKeyExported = await window.crypto.subtle.exportKey(
                    "spki",
                    ephemeralKeyPair.publicKey
                );
                
                // Derive a shared secret
                const sharedSecretBits = await window.crypto.subtle.deriveBits(
                    {
                        name: "ECDH",
                        public: publicKey
                    },
                    ephemeralKeyPair.privateKey,
                    256 // Number of bits to derive
                );
                
                // Convert shared secret to key for AES-GCM
                const sharedSecretKey = await window.crypto.subtle.importKey(
                    "raw",
                    sharedSecretBits,
                    {
                        name: "AES-GCM",
                    },
                    false,
                    ["encrypt"]
                );
                
                // Generate a random IV
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                
                // Encrypt the message
                const messageBuffer = stringToArrayBuffer(messageToEncrypt);
                const encryptedBuffer = await window.crypto.subtle.encrypt(
                    {
                        name: "AES-GCM",
                        iv: iv
                    },
                    sharedSecretKey,
                    messageBuffer
                );
                
                // Combine all parts for transmission
                const result = {
                    curve: curve,
                    ephemeralPublicKey: arrayBufferToBase64(ephemeralPublicKeyExported),
                    iv: arrayBufferToBase64(iv),
                    encryptedData: arrayBufferToBase64(encryptedBuffer)
                };
                
                // Display the encrypted message
                document.getElementById('encryptedMessage').value = JSON.stringify(result);
                
            } catch (error) {
                console.error('Encryption error:', error);
                alert("Encryption failed. Please check the public key format.");
            }
        }
        
        // Decrypt message
        async function decryptMessage() {
            const privateKeyJson = document.getElementById('decryptPrivateKey').value.trim();
            const encryptedMessageJson = document.getElementById('messageToDecrypt').value.trim();
            
            if (!privateKeyJson) {
                alert("Please enter a private key.");
                return;
            }
            
            if (!encryptedMessageJson) {
                alert("Please enter a message to decrypt.");
                return;
            }
            
            try {
                // Parse the private key JSON
                const privateKeyData = JSON.parse(privateKeyJson);
                const privateKeyCurve = privateKeyData.curve;
                const privateKeyBase64 = privateKeyData.key;
                
                // Parse the encrypted message JSON
                const encryptedData = JSON.parse(encryptedMessageJson);
                const messageCurve = encryptedData.curve;
                const ephemeralPublicKeyBase64 = encryptedData.ephemeralPublicKey;
                const ivBase64 = encryptedData.iv;
                const encryptedDataBase64 = encryptedData.encryptedData;
                
                // Check if curves match
                if (privateKeyCurve !== messageCurve) {
                    throw new Error(`Curve mismatch: key uses ${privateKeyCurve} but message uses ${messageCurve}`);
                }
                
                // Convert base64 to ArrayBuffer
                const privateKeyBuffer = base64ToArrayBuffer(privateKeyBase64);
                const ephemeralPublicKeyBuffer = base64ToArrayBuffer(ephemeralPublicKeyBase64);
                const ivBuffer = base64ToArrayBuffer(ivBase64);
                const encryptedBuffer = base64ToArrayBuffer(encryptedDataBase64);
                
                // Import the private key
                const privateKey = await window.crypto.subtle.importKey(
                    "pkcs8",
                    privateKeyBuffer,
                    {
                        name: "ECDH",
                        namedCurve: privateKeyCurve
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
                
                // Import the ephemeral public key
                const ephemeralPublicKey = await window.crypto.subtle.importKey(
                    "spki",
                    ephemeralPublicKeyBuffer,
                    {
                        name: "ECDH",
                        namedCurve: messageCurve
                    },
                    true,
                    []
                );
                
                // Derive the same shared secret
                const sharedSecretBits = await window.crypto.subtle.deriveBits(
                    {
                        name: "ECDH",
                        public: ephemeralPublicKey
                    },
                    privateKey,
                    256 // Same number of bits as during encryption
                );
                
                // Import as AES-GCM key
                const sharedSecretKey = await window.crypto.subtle.importKey(
                    "raw",
                    sharedSecretBits,
                    {
                        name: "AES-GCM",
                    },
                    false,
                    ["decrypt"]
                );
                
                // Decrypt the message
                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    {
                        name: "AES-GCM",
                        iv: new Uint8Array(ivBuffer)
                    },
                    sharedSecretKey,
                    new Uint8Array(encryptedBuffer)
                );
                
                // Convert to string
                const decryptedMessage = arrayBufferToString(decryptedBuffer);
                
                // Display the decrypted message
                document.getElementById('decryptedMessage').value = decryptedMessage;
                
            } catch (error) {
                console.error('Decryption error:', error);
                alert(`Decryption failed: ${error.message}. Please check that you're using the correct private key.`);
            }
        }
        
        // Save keys to file
        function saveKeysToFile() {
            const publicKey = document.getElementById('publicKeyDisplay').value;
            const privateKey = document.getElementById('privateKeyDisplay').value;
            
            if (!publicKey || !privateKey) {
                alert("Please generate keys first.");
                return;
            }
            
            const keyData = {
                publicKey: publicKey,
                privateKey: privateKey
            };
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(keyData));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "ecc_encryption_keys.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
        
        // Load keys from file
        function loadKeysFromFile(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const keyData = JSON.parse(e.target.result);
                    
                    if (keyData.publicKey && keyData.privateKey) {
                        document.getElementById('publicKeyDisplay').value = keyData.publicKey;
                        document.getElementById('privateKeyDisplay').value = keyData.privateKey;
                        document.getElementById('decryptPrivateKey').value = keyData.privateKey;
                    } else {
                        throw new Error("Invalid key file format");
                    }
                } catch (error) {
                    console.error('Error loading keys:', error);
                    alert("Failed to load keys. The file format is invalid.");
                }
            };
            
            reader.readAsText(file);
        }
        
        // Run an end-to-end test
        async function runEndToEndTest() {
            const testResultsDiv = document.getElementById('testResults');
            const testResultsContent = document.getElementById('testResultsContent');
            const runTestBtn = document.getElementById('runTestBtn');
            const testMessage = document.getElementById('testMessage').value || "This is a test message to verify that the encryption and decryption functionality works correctly.";
            
            // Disable button and show loading
            runTestBtn.disabled = true;
            runTestBtn.textContent = "Running Test...";
            testResultsContent.innerHTML = "<p>Test in progress...</p>";
            testResultsDiv.style.display = "block";
            
            try {
                // Step 1: Generate a new key pair
                testResultsContent.innerHTML += "<p>✓ Generating new key pair...</p>";
                
                const curve = "P-256"; // Use P-256 for the test
                
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: curve
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
                
                // Export public key to spki format
                const publicKeyExported = await window.crypto.subtle.exportKey(
                    "spki",
                    keyPair.publicKey
                );
                
                // Export private key to pkcs8 format
                const privateKeyExported = await window.crypto.subtle.exportKey(
                    "pkcs8",
                    keyPair.privateKey
                );
                
                // Convert to base64 for storage and display
                const publicKeyBase64 = arrayBufferToBase64(publicKeyExported);
                const privateKeyBase64 = arrayBufferToBase64(privateKeyExported);
                
                // Add curve info to the keys for later use
                const publicKeyWithCurve = JSON.stringify({
                    curve: curve,
                    key: publicKeyBase64
                });
                
                const privateKeyWithCurve = JSON.stringify({
                    curve: curve,
                    key: privateKeyBase64
                });
                
                testResultsContent.innerHTML += "<p>✓ Key pair generated successfully!</p>";
                
                // Step 2: Encrypt the test message
                testResultsContent.innerHTML += "<p>✓ Encrypting test message...</p>";
                
                // Parse the public key JSON to get curve and key
                const publicKeyData = JSON.parse(publicKeyWithCurve);
                const publicKeyBuffer = base64ToArrayBuffer(publicKeyData.key);
                
                // Import the public key
                const publicKey = await window.crypto.subtle.importKey(
                    "spki",
                    publicKeyBuffer,
                    {
                        name: "ECDH",
                        namedCurve: curve
                    },
                    true,
                    []
                );
                
                // Generate an ephemeral key pair for this encryption
                const ephemeralKeyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: curve
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
                
                // Export the ephemeral public key to send along with the message
                const ephemeralPublicKeyExported = await window.crypto.subtle.exportKey(
                    "spki",
                    ephemeralKeyPair.publicKey
                );
                
                // Derive a shared secret
                const sharedSecretBits = await window.crypto.subtle.deriveBits(
                    {
                        name: "ECDH",
                        public: publicKey
                    },
                    ephemeralKeyPair.privateKey,
                    256
                );
                
                // Convert shared secret to key for AES-GCM
                const sharedSecretKey = await window.crypto.subtle.importKey(
                    "raw",
                    sharedSecretBits,
                    {
                        name: "AES-GCM",
                    },
                    false,
                    ["encrypt"]
                );
                
                // Generate a random IV
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                
                // Encrypt the message
                const messageBuffer = stringToArrayBuffer(testMessage);
                const encryptedBuffer = await window.crypto.subtle.encrypt(
                    {
                        name: "AES-GCM",
                        iv: iv
                    },
                    sharedSecretKey,
                    messageBuffer
                );
                
                // Combine all parts for transmission
                const encryptedResult = {
                    curve: curve,
                    ephemeralPublicKey: arrayBufferToBase64(ephemeralPublicKeyExported),
                    iv: arrayBufferToBase64(iv),
                    encryptedData: arrayBufferToBase64(encryptedBuffer)
                };
                
                const encryptedMessage = JSON.stringify(encryptedResult);
                
                testResultsContent.innerHTML += "<p>✓ Message encrypted successfully!</p>";
                
                // Step 3: Decrypt the message
                testResultsContent.innerHTML += "<p>✓ Decrypting message...</p>";
                
                // Parse the private key JSON
                const privateKeyData = JSON.parse(privateKeyWithCurve);
                const privateKeyBuffer = base64ToArrayBuffer(privateKeyData.key);
                
                // Parse the encrypted message JSON
                const encryptedData = JSON.parse(encryptedMessage);
                const ephemeralPublicKeyBuffer = base64ToArrayBuffer(encryptedData.ephemeralPublicKey);
                const ivBuffer = base64ToArrayBuffer(encryptedData.iv);
                const encryptedBuffer2 = base64ToArrayBuffer(encryptedData.encryptedData);
                
                // Import the private key
                const privateKey = await window.crypto.subtle.importKey(
                    "pkcs8",
                    privateKeyBuffer,
                    {
                        name: "ECDH",
                        namedCurve: curve
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
                
                // Import the ephemeral public key
                const ephemeralPublicKey = await window.crypto.subtle.importKey(
                    "spki",
                    ephemeralPublicKeyBuffer,
                    {
                        name: "ECDH",
                        namedCurve: curve
                    },
                    true,
                    []
                );
                
                // Derive the same shared secret
                const sharedSecretBits2 = await window.crypto.subtle.deriveBits(
                    {
                        name: "ECDH",
                        public: ephemeralPublicKey
                    },
                    privateKey,
                    256
                );
                
                // Import as AES-GCM key
                const sharedSecretKey2 = await window.crypto.subtle.importKey(
                    "raw",
                    sharedSecretBits2,
                    {
                        name: "AES-GCM",
                    },
                    false,
                    ["decrypt"]
                );
                
                // Decrypt the message
                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    {
                        name: "AES-GCM",
                        iv: new Uint8Array(ivBuffer)
                    },
                    sharedSecretKey2,
                    new Uint8Array(encryptedBuffer2)
                );
                
                // Convert to string
                const decryptedMessage = arrayBufferToString(decryptedBuffer);
                
                testResultsContent.innerHTML += "<p>✓ Message decrypted successfully!</p>";
                
                // Step 4: Verify the result
                if (decryptedMessage === testMessage) {
                    testResultsContent.innerHTML += 
                        `<p><strong style="color: green;">✓ Test passed! The decrypted message matches the original.</strong></p>
                         <p><strong>Original message:</strong> "${testMessage}"</p>
                         <p><strong>Decrypted message:</strong> "${decryptedMessage}"</p>`;
                } else {
                    testResultsContent.innerHTML += 
                        `<p><strong style="color: red;">❌ Test failed! The decrypted message does not match the original.</strong></p>
                         <p><strong>Original message:</strong> "${testMessage}"</p>
                         <p><strong>Decrypted message:</strong> "${decryptedMessage}"</p>`;
                }
                
            } catch (error) {
                console.error('Test error:', error);
                testResultsContent.innerHTML += `<p><strong style="color: red;">❌ Test failed with error: ${error.message}</strong></p>`;
            } finally {
                // Re-enable button
                runTestBtn.disabled = false;
                runTestBtn.textContent = "Run End-to-End Test";
            }
        }
    </script>
</body>
</html>